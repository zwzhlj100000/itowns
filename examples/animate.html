    <!DOCTYPE html>
    <html>
        <head>
            <title>Globe</title>

        <style type="text/css">
                html {height: 100%}
            body { margin: 0; overflow:hidden; height:100%}

                #viewerDiv {
                    margin : auto auto;
                    width: 100%;
                    height: 100%;
                    padding: 0;
                }
                #menuDiv {position: absolute; top:0px; margin-left: 0px;}
            </style>
            <meta charset="UTF-8">

            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.1/dat.gui.min.js"></script>
        </head>
        <body>
            <div id="viewerDiv"></div>
            <script src="/examples/GUI/GuiTools.js"></script>
            <script src="/dist/itowns.js"></script>
            <script src="/dist/debug.js"></script>
            <!-- from https://github.com/mrdoob/three.js/blob/master/examples/js/shaders/DotScreenShader.js -->

            <script type="x-shader/x-vertex" id="vertexshader">
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            </script>

            <script type="x-shader/x-fragment" id="fragmentshader">
                uniform vec2 center;
                uniform float angle;
                uniform float scale;
                uniform vec2 tSize;
                uniform float time;

                uniform sampler2D tDiffuse;
                uniform sampler2D tClasses;

                varying vec2 vUv;
                vec4 color;
                float coefMix;

                #define M_PI 3.1415926535897932384626433832795

                // function return if class is water only
                bool checkWater(vec4 colorClasses, vec4 colorClassesDelta){

                    return 
                        colorClasses == vec4(0.,1.,0.,1.) && colorClassesDelta == vec4(0.,1.,0.,1.);

                    /*  colorClasses.g == 1. && colorClassesDelta.g == 1. &&
                        colorClasses.r <= 0.1 && colorClassesDelta.r <= 0.1 );
                     */
                }

                // Return true if color is building
                bool checkBuilding( vec4 color ){
                    return color.r == 1.;
                }

                // Return true if color is Road
                bool checkRoad( vec4 colorClasses, vec4 colorClassesDelta){
                   return (
                        colorClasses.b > 0.9 && colorClassesDelta.b > 0.9
                       // colorClasses.r <= 0.1 && colorClassesDelta.r <= 0.1
                         );
                }


    /*
                // Return true if at least one neighbour is a building
                bool check8Connex(vec2 uv, sampler2D tex){

                    vec4 e0 = texture2D(tex, vec2(uv.x - 1, uv.y - 1));
                    vec4 e1 = texture2D(tex, vec2(uv.x - 0, uv.y - 1));
                    vec4 e2 = texture2D(tex, vec2(uv.x + 1, uv.y - 1));
                    vec4 e3 = texture2D(tex, vec2(uv.x - 1, uv.y - 0));
                    vec4 e4 = texture2D(tex, vec2(uv.x + 1, uv.y - 0));
                    vec4 e5 = texture2D(tex, vec2(uv.x - 1, uv.y + 1));
                    vec4 e6 = texture2D(tex, vec2(uv.x - 0, uv.y + 1));
                    vec4 e7 = texture2D(tex, vec2(uv.x + 1, uv.y + 1));

                    return checkBuilding(e0) || checkBuilding(e1) || checkBuilding(e2) || 
                           checkBuilding(e3) || checkBuilding(e4) || 
                           checkBuilding(e5) || checkBuilding(e6) || checkBuilding(e7);
                }

    */
                // This function compute distance between original pixel and other class object
                float checkDistanceToObstacle(vec2 uv, sampler2D tex){

                    const float maxDistance = 0.03;
                    float minDistance = maxDistance;

                    vec4 colorClassesDelta = texture2D( tex, uv);

                    if (!checkBuilding (colorClassesDelta)) {

                        for (float i = -maxDistance; i< maxDistance; i+= maxDistance / 10.) {

                            for (float j = -maxDistance; j< maxDistance; j+= maxDistance / 10.) {
                            
                                if (checkBuilding( texture2D(tex, vec2(uv.x + i, uv.y + j)) )){
                                    float dist = sqrt (i * i + j * j);
                                    if(dist < minDistance) minDistance = dist;
                                }
                            }
                        }

                    }

                    return minDistance;
                }


                // For Road
                // Returns the local axis of the object from class colorClass at coord uv
                vec2 getLocalObjectAxis(vec2 uv, sampler2D tex, vec4 colorClass){

                    const float inc = M_PI / 16.;
                    float d = 0.01;
                    const float incDistance = 0.002;
                    const float maxDistance = 0.04;
                    float angularOri = 0.;
                    vec2 outputVec = vec2(0.);

                    for (float i = 0.; i < 2. * M_PI; i += inc){

                        // Then we compute the max distance from the current position to the limit of the object
                        for (float a = 0.; a <= maxDistance; a += incDistance){
                            vec2 currentCoord = vec2( uv.x + a * cos(i), uv.y + a * sin(i));
                            vec4 col = texture2D( tex, currentCoord);
                            bool inside = col.b == 1.;//col == colorClass;
                            if (!inside) break;
                            if(inside && a >= 0.038/*== maxDistance*/) {angularOri = i; outputVec = vec2(cos(i), sin(i)); break;}  
                        }
                    }

                    return outputVec;
                }


                // Returns the local axis of the object from class colorClass at coord uv
                vec2 getLocalObjectAxisWater(vec2 uv, sampler2D tex, vec4 colorClass){

                    const float inc = M_PI / 48.;
                    float d = 0.01;
                    const float incDistance = 0.004;
                    const float maxDistance = 0.2;
                    float angularOri = 0.;
                    vec2 outputVec = vec2(0.);

                    for (float i = 0.; i < 2. * M_PI; i += inc){

                        // Then we compute the max distance from the current position to the limit of the object
                        for (float a = 0.; a <= maxDistance; a += incDistance){
                            vec2 currentCoord = vec2( uv.x + a * cos(i), uv.y + a * sin(i));
                            vec4 col = texture2D( tex, currentCoord);
                            bool inside = col.g == 1.;//col == colorClass;
                            if (!inside) break;
                            if(inside && a >= maxDistance * 0.9/*== maxDistance*/) {angularOri = i; outputVec = vec2(cos(i), sin(i)); break;}  
                        }
                    }

                    return outputVec;
                }


                // Returns the local axis of the object from class colorClass at coord uv
                vec2 getLocalObjectAxisWater2(vec2 uv, sampler2D tex, vec4 colorClass){

                    const float inc = M_PI / 48.;
                    float d = 0.01;
                    const float incDistance = 0.004;
                    const float maxDistance = 0.4;
                    vec2 outputVec = vec2(0.);
                    float distMinSeg = 0.02;
                    bool firstCoord = true;
                    vec2 p1 = vec2(0.);
                    vec2 p2 = vec2(0.);
                    bool founded = false;
                    float pivotIfOut = 0.;
                    bool relaunch = false;


                    for (float i = 0.; i < 2. * M_PI; i += inc){

                        if(founded || relaunch) break;
                        // Then we compute the max distance from the current position to the limit of the object
                        for (float a = 0.; a <= maxDistance; a += incDistance){

                            vec2 currentCoord = vec2( uv.x + a * cos(i + pivotIfOut), uv.y + a * sin(i + pivotIfOut));
                            if(currentCoord.x > 1. || currentCoord.x < 0. || currentCoord.y > 1. || currentCoord.y < 0. || a >= maxDistance - incDistance && !founded){
                               // pivotIfOut = M_PI / 2.;
                                relaunch = true;
                                break;
                                //firstCoord = true;
                                //currentCoord = vec2( uv.x + a * cos(i + pivotIfOut), uv.y + a * sin(i + pivotIfOut));
                            }else{
                                vec4 col = texture2D( tex, currentCoord);
                                bool inside = col.g == 1.;//col == colorClass;

                                if (!inside){
                                    if(firstCoord){ 
                                        firstCoord = false;
                                        p1 = currentCoord;
                                    }
                                    //p2 = currentCoord;
                                    if (distance(p2,p1) > distMinSeg){
                                        p2 = currentCoord;
                                        founded = true;
                                        break;
                                    } 
                                } 
                            }
                           // if(inside && a >= maxDistance * 0.9/*== maxDistance*/) {angularOri = i; outputVec = vec2(cos(i), sin(i)); break;}  
                        }
                    }

                    if(relaunch){

                        pivotIfOut = M_PI / 2.;
                        firstCoord = true;
                        founded = false;
                        for (float i = 0.; i < 2. * M_PI; i += inc){

                            if(founded) break;
                            // Then we compute the max distance from the current position to the limit of the object
                            for (float a = 0.; a <= maxDistance; a += incDistance){

                                vec2 currentCoord = vec2( uv.x + a * cos(i + pivotIfOut), uv.y + a * sin(i + pivotIfOut));
                                vec4 col = texture2D( tex, currentCoord);
                                bool inside = col.g == 1.;

                                if (!inside){
                                    if(firstCoord){ 
                                        firstCoord = false;
                                        p1 = currentCoord;
                                    }
                                    //p2 = currentCoord;
                                    if (distance(p2,p1) > distMinSeg){
                                        p2 = currentCoord;
                                        founded = true;
                                        break;
                                    } 
                                } 
                            }
                        }
                    }

                    outputVec = p2 - p1;

                    return outputVec;
                }


                  // Version 3 computing distance around point and returning perpedicular axis to minimum axis
                  // We turn around point to computing minimum distance.
                vec2 getLocalObjectAxisWater3(vec2 uv, sampler2D tex, vec4 colorClass){
                    
                    const float inc = M_PI / 12.;
                    float d = 0.01;
                    const float incDistance = 0.002;
                    const float maxDistance = 0.3;
                    vec2 p1 = vec2(0.);
                    vec2 p2 = vec2(10.);
                    vec2 outVec = vec2(0.);
                    float distanceMin = 2.;

                    for (float i = 0.; i < 2. * M_PI; i += inc){

                        p1 = vec2(-10.);
                        p2 = vec2(10.);

                        // Look first extremity
                        for (float a = 0.; a <= maxDistance; a += incDistance){

                            vec2 currentCoord1 = vec2( uv.x + a * cos(i), uv.y + a * sin(i));
                            vec4 col1 = texture2D( tex, currentCoord1);
                            bool inside = col1.g == 1.;
                            if (!inside && currentCoord1.x > 0. && currentCoord1.x < 1. && currentCoord1.y < 1. && currentCoord1.y > 0.) {p1 = currentCoord1; break;}
                        }
                        // Look opposite extremity
                        for (float a = 0.; a >= -maxDistance; a -= incDistance){

                            vec2 currentCoord2 = vec2( uv.x + a * cos(i), uv.y + a * sin(i));
                            vec4 col2 = texture2D( tex, currentCoord2);
                            bool inside = col2.g == 1.;
                            if (!inside&& currentCoord2.x > 0. && currentCoord2.x < 1. && currentCoord2.y < 1. && currentCoord2.y > 0.) {p2 = currentCoord2; break;}
                        }

                        // We compute length of segment
                        d = distance(p1,p2);//length(p2 - p1);
                        if(d < distanceMin){
                            distanceMin = d;
                            outVec = p2 - p1;
                        }

                    }

                    // Optional normalization at PI/4;
                    outVec = vec2(-outVec.x, outVec.y);  // Orthogonal vector
                    float alpha = atan(outVec.y, outVec.x);
                    alpha = floor(alpha / (M_PI / 8.)) * (M_PI / 8.); 
                    vec2 normalizedOutVec = vec2(cos(alpha), sin(alpha));

                    return vec2(alpha / (2.* M_PI), alpha / (2.* M_PI)); //normalizedOutVec; // vec2(-outVec.x, outVec.y);

                }




                void main() {

                    float modTime = mod(time, 0.4);
                    float modVal = 0.04;

                    vec2 nextUV = vec2( vUv.x * (1. - modTime), vUv.y /* * (1. - time) */);
                    vec2 nextUVCars; // = vec2( vUv.x /* * (1. - time * 3.)*/, vUv.y * (1. - modTime *  3.) );

                    vec4 currentColor = texture2D( tDiffuse, vUv);
                    vec4 colorClasses = texture2D( tClasses, vUv );
                    vec4 colorClassesDelta;
                    vec4 colorClassesDeltaCars;

                    float minDistance = 0.; //0.03; // checkDistanceToObstacle(nextUV, tClasses);
                    vec2 axis = vec2(0., 0.);

                    color = currentColor;



                    if(colorClasses.b  == 1.){           // ROAD
                        axis = getLocalObjectAxis(vUv, tClasses, vec4(0., 0., 1., 1.));
                        nextUVCars = vUv + vec2( mod(axis.x * modTime * 4., modVal), mod(axis.y * modTime * 4., modVal)); //vUv + 4. * axis * modTime;
                        //nextUVCars = vec2( vUv.x * (1. + axis.x * modTime*4.), vUv.y  * (1. + axis.y * modTime*4.) );
                        colorClassesDeltaCars = texture2D(tClasses, nextUVCars);
                        if(colorClassesDeltaCars.b == 1.){
                            color = texture2D( tDiffuse, nextUVCars); minDistance = 1.;
                        }
                    }else{

                        if(colorClasses.r == 1.){        // BUILDING
                            // We don't need to do anything
                        }else

                            if(colorClasses.g == 1.){    // WATER
                                axis =  getLocalObjectAxisWater3(vUv, tClasses, vec4(0., 1., 0., 1.));
                                nextUV = vUv + vec2( mod(axis.x * modTime * 1., modVal), mod(axis.y * modTime * 1., modVal));//vec2( mod(axis.x + modTime , 0.04), mod(axis.y + modTime , 0.04)); //vec2(vUv.x * (axis.x + modTime), vUv.y )
                                colorClassesDelta = texture2D( tClasses, nextUV);
                                if( colorClassesDelta == vec4(0., 1., 0., 1.)) {  // if it is only water
                                    minDistance = checkDistanceToObstacle(nextUV, tClasses);
                                    color = mix(currentColor, texture2D( tDiffuse, nextUV), min(minDistance * (1. / 0.03), 1.) );
                                }
                            }
                    }

                    gl_FragColor = vec4(vec2( abs(axis.x) * 5., abs(axis.y) * 5.), 0., 1.);// color; //vec4(vec2( abs(axis.x) * 5., abs(axis.y) * 5.), 0., 1.);//color; // mix(color, colorClasses, 0.5); //vec4(vec3(minDistance * 100.), 1.); //color; // colorClasses

                }

/*

                    if(colorClasses.b  == 1.){   // ROAD
                        axis = getLocalObjectAxis(vUv, tClasses, vec4(0., 0., 1., 1.));
                        nextUVCars = vUv + vec2( mod(axis.x * modTime * 4., 0.02), mod(axis.y * modTime * 4., 0.02));//vUv + 4. * axis * modTime;
                        //nextUVCars = vec2( vUv.x * (1. + axis.x * modTime*4.), vUv.y  * (1. + axis.y * modTime*4.) );
                        colorClassesDeltaCars = texture2D( tClasses, nextUVCars);
                        nextColorCars = texture2D( tDiffuse, nextUVCars);
                    }


                    if (colorClasses.g == 1.){ //checkWater( colorClasses, colorClassesDelta)){  // WATER
                        axis =  getLocalObjectAxisWater(vUv, tClasses, vec4(0., 1., 0., 1.));
                        nextUV = vUv + vec2( mod(axis.x + modTime , 0.04), mod(axis.y + modTime , 0.04));//vec2(vUv.x * (axis.x + modTime), vUv.y )//vUv + vec2( mod(axis.x * modTime , 0.04), mod(axis.y * modTime , 0.04));//vUv + 4. * axis * modTime;

                        if( texture2D( tClasses, nextUV) == vec4(0., 1., 0., 1.)) {  // if it is only water
                            color = texture2D( tDiffuse, nextUV);
                            minDistance = checkDistanceToObstacle(nextUV, tClasses);
                        } else color = currentColor;
                    }
                    else
                        if (checkRoad( colorClasses, colorClassesDeltaCars)){
                            color = nextColorCars; minDistance = 1.;//vec4(0.,0.,1.,1.); nextColor;
                        }
                        else
                            color = currentColor;

                    color = mix(currentColor, color,  min(minDistance * (1. / 0.03), 1.) ); // vec4(vec3(minDistance * (1./ 0.03)), 1.); // vec4(axis, 1., 1.);//


                    gl_FragColor = color; // mix(color, colorClasses, 0.5); //vec4(vec3(minDistance * 100.), 1.); //color; // colorClasses

                   // if(axis.x > 0.9 || axis.x < - 0.9) gl_FragColor = vec4(1., 1., 1., 1.);
                   // if(axis.y > 0.9 || axis.y < - 0.9) gl_FragColor = vec4(1., 0., 1., 1.);
                }
*/
            </script>

            <script type="text/javascript">
                /* global itowns,document,GuiTools*/

                const positionOnGlobe = { longitude: 2.351323, latitude: 48.856712, altitude: 1000 };

                // iTowns namespace defined here
                const viewerDiv = document.getElementById('viewerDiv');

                const menuGlobe = new GuiTools('menuDiv');
                const globeView = new itowns.GlobeView(viewerDiv, positionOnGlobe);
                menuGlobe.view = globeView;

                itowns.Fetcher.json('layers/JSONLayers/Ortho.json').then(result => {globeView.addLayer(result);
                   itowns.Fetcher.json('layers/JSONLayers/Hydro.json').then(result => { globeView.addLayer(result);
                     itowns.Fetcher.json('layers/JSONLayers/Batiments.json').then(result => {globeView.addLayer(result);
                          itowns.Fetcher.json('layers/JSONLayers/Roads.json').then(result => globeView.addLayer(result))
                    })
                  })
               });

                menuGlobe.addGUI('RealisticLighting', false,
                    (newValue) => { globeView.setRealisticLightingOn(newValue); });

                globeView.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, () => {
                    // eslint-disable-next-line no-console
                    console.info('Globe initialized');
                    menuGlobe.addImageryLayersGUI(globeView.getLayers(l => l.type === 'color'));
                    menuGlobe.addElevationLayersGUI(globeView.getLayers(l => l.type === 'elevation'));
                });


                 menuGlobe.addGUI('Classification', false,
                    (newValue) => { globeView.setClassificationOn(newValue); });



                // Simple postprocessing setup
                //
                const postprocessScene = new itowns.THREE.Scene();
                const quad = new itowns.THREE.Mesh( new itowns.THREE.PlaneBufferGeometry( 2, 2 ), null);
                quad.frustumCulled = false;
                quad.material = new itowns.THREE.ShaderMaterial( {
                    uniforms: {
                        "tDiffuse": { value: null },  // Original image (with optional dection output debug) 
                        "tClasses": { value: null },  // Classes image (one color per object class (layer))
                        "tSize":    { value: new itowns.THREE.Vector2( 256, 256 ) },
                        "center":   { value: new itowns.THREE.Vector2( 0.5, 0.5 ) },
                        "angle":    { value: 1.57 },
                        "scale":    { value: 1.0 },
                        "time":     { value: 0.  },
                    },
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                } );
                postprocessScene.add(quad);
                const cam = new itowns.THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);



                globeView.render = () => {
                    const g = globeView.mainLoop.gfxEngine;
                    const r = g.renderer;
                    r.setRenderTarget(g.fullSizeRenderTarget);
                    r.clear();
                    r.setViewport(0, 0, g.getWindowSize().x, g.getWindowSize().y);

                // RENDER NORMAL IMAGERY
                    r.render(
                        globeView.scene,
                        globeView.camera.camera3D, g.fullSizeRenderTarget);
                    //var t0 = performance.now();
                    r.readRenderTargetPixels( g.fullSizeRenderTarget, 0, 0, g.getWindowSize().x, g.getWindowSize().y, globeView.arrayRTT );
                    globeView.rttTexture.needsUpdate = true;

                // RENDER ONLY OBJECT CLASSES (layer)
                    globeView.setClassesOnly(true);
                    r.setRenderTarget(g.fullSizeRenderTargetCLASSES);
                    r.clear();
                    r.render(
                        globeView.scene,
                        globeView.camera.camera3D, g.fullSizeRenderTargetCLASSES);
                    //var t0 = performance.now();
                    r.readRenderTargetPixels( g.fullSizeRenderTargetCLASSES, 0, 0, g.getWindowSize().x, g.getWindowSize().y, globeView.arrayRTTCLASSES );
                    globeView.rttTextureCLASSES.needsUpdate = true;
                    globeView.setClassesOnly(false);
                            // const gl = g.renderer.context;
                            // var fb = gl.createFramebuffer();
                            // gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
                            // gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                            // gl.readPixels( 0, 0, g.getWindowSize().x, g.getWindowSize().y, gl.RGBA, gl.G_HALF_FLOAT, globeView.arrayRTT );


                    var cvTexture;
                    //var t1 = performance.now();    
                    if(globeView.classificationOn){
                        var segmentation = new itowns.Segmentation();
                        segmentation.setImage(globeView.rttTexture, globeView.rttTextureCLASSES);//g.fullSizeRenderTarget);
                        cvTexture = segmentation.extractCars();
                    } else
                        cvTexture = globeView.rttTexture;
                    //var t2 = performance.now();
                    // console.log(t1 - t0,"  ",t2-t1);

                    quad.material.uniforms["tDiffuse"].value = cvTexture;//g.fullSizeRenderTarget.texture;
                    quad.material.uniforms["tClasses"].value = globeView.rttTextureCLASSES;//g.fullSizeRenderTarget.texture;
                    quad.material.uniforms["time"].value += 0.00008;
                   // quad.material.uniforms["tSize"].value.set(
                   //     g.fullSizeRenderTarget.width, g.fullSizeRenderTarget.height);

                    r.setRenderTarget();
                    r.clear();
                    r.setViewport(0, 0, g.getWindowSize().x, g.getWindowSize().y);
                    r.render(
                        postprocessScene,
                        cam);

                };


                // Force render each frame (dirty mode)
                forceRender = function () {
                     
                        requestAnimationFrame(forceRender);
                        globeView.render();
                };

                forceRender();
                

    </script>
        </body>
    </html>
